/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "JacobianRBWPdf.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(JacobianRBWPdf) 

 JacobianRBWPdf::JacobianRBWPdf(const char *name, const char *title, 
                        RooAbsReal& _mt,
                        RooAbsReal& _mass,
                        RooAbsReal& _width) :
   RooAbsPdf(name,title), 
   mt("mt","mt",this,_mt),
   mass("mass","mass",this,_mass),
   width("width","width",this,_width)
 { 
 } 


 JacobianRBWPdf::JacobianRBWPdf(const JacobianRBWPdf& other, const char* name) :  
   RooAbsPdf(other,name), 
   mt("mt",this,other.mt),
   mass("mass",this,other.mass),
   width("width",this,other.width)
 { 
 } 



 Double_t JacobianRBWPdf::evaluate() const 
 { 
   if (mt <= 0 || width <= 0 || mass <= 0)return 0;

   // The width of the integration bins will be variable in En (W' energy). 
   // A smaller number here means a more accurate (but more time-consuming) integral
   const Double_t accuracy = 0.1;

   // Small numbers here makes the integral more accurate at the expense of time.
   const Double_t minWidth = 0.01;
   const Double_t maxWidth = 1;

   // We do not want to go to infinity.  That would take a long time.
   const Double_t maxEn = 8000;

   // Some constants
   //   const float M_W = 80.399;
   // const float G_W = 2.085;
   //   Double_t width_prime = (4./3.)*(mass/M_W)*G_W;
   const Double_t M2 = mass * mass;
   //   const Double_t M2G2 = M2 * width_prime * width_prime;
   const Double_t M2G2 = M2 * width * width;
   const Double_t mt2 = mt * mt;
   const Double_t denom = accuracy / (M2 * M2 * mt2 * mt2);
   
   // The current bin width.  Begins at 0.
   Double_t binWidth = 0;
   // A cache from the previous iteration
   Double_t cache = 0;
   // The return value
   Double_t ret = 0;

   //   std::cout << "Calculating integral for mt=" << mt << ", M=" << mass << ", G=" << width << "... ";
   
   // loop over W' energy in RBW times Jacobian convolution
   for (Double_t En = mt + minWidth; En < maxEn; En += binWidth) {
     
     Double_t s = En * En;

     // Calculate the value of the integrand at this s
     const Double_t smM2 = s - M2;
     const Double_t smmt2 = s - mt2;
     const Double_t r = mt2/s;
     Double_t value = (2-r) * JacobianRBWPdf::fastInvSqrt(1-r)
       / (smM2 * smM2 + M2G2) / s;

     // Add the trapezoid using the previous iteration value
     if (value < 0) value = 0;
     ret += 0.5 * binWidth * (value + cache);
     // Cache the calculated value
     cache = value;
     // Update the new bin width to focus on points where the distribution blows up
     binWidth = smM2 * smM2 * smmt2 * smmt2 * denom;
     if (binWidth < minWidth) binWidth = minWidth;
     else if (binWidth > maxWidth) binWidth = maxWidth;
     
     //     std::cout << "s=" << s << " mt=" << mt << " M=" << mass << " binWidth=" << binWidth << std::endl;
   }

   // std::cout << "ret = " << (mt * ret) << std::endl;
   return mt * ret;

 } 


// fast inverse square root (from wikipedia!)
float JacobianRBWPdf::fastInvSqrt(float x)
{
  union {
    float f;
    int i;
  } tmp;
  tmp.f = x;
  tmp.i = 0x5f3759df - (tmp.i >> 1);
  float y = tmp.f;
  return y * (1.5f - 0.5f * x * y * y);
}
